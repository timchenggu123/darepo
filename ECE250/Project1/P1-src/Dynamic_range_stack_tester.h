

/*************************************************
 * Dynamic_range_stack_tester
 * A class for testing dynamic range stacks.
 *
 * Author:  Douglas Wilhelm Harder
 * Copyright (c) 2006-10 by Douglas Wilhelm Harder.  All rights reserved.
 *
 * DO NOT EDIT THIS FILE
 *************************************************/

#ifndef DYNAMIC_RANGE_STACK_TESTER_H
#define DYNAMIC_RANGE_STACK_TESTER_H

#ifndef nullptr
#define nullptr 0
#endif

#include "Exception.h"
#include "Tester.h"
#include "Dynamic_range_stack.h"

#include <iostream>

class Dynamic_range_stack_tester:public Tester< Dynamic_range_stack > {
	using Tester< Dynamic_range_stack >::object;
	using Tester< Dynamic_range_stack >::command;

	public:
		Dynamic_range_stack_tester( Dynamic_range_stack *obj = 0 ):Tester< Dynamic_range_stack >( obj ) {
			// empty
		}

		void process();
};

/****************************************************
 * void process()
 *
 * Process the current command.  For dynamic stack-as-arrays, these include:
 *
 *  Constructors
 *
 *   new             constructor     create a stack with the default array size
 *   new: n          constructor     create a stack with an array size of n
 *
 *  Accessors
 *
 *   size n          size            the size equals n
 *   capacity n      capacity        the capcity equals n
 *   empty b         empty           the result is the Boolean value b
 *   top n           top             n is the top element in the stack
 *   top!            top             the underflow exception is thrown
 *   max n           maximum         n is the maximum element in the stack
 *   max!            maximum         the underflow exception is thrown
 *   min n           minimum         n is the minimum element in the stack
 *   min!            minimum         the underflow exception is thrown
 *
 *  Mutators
 *
 *   push n          push            the element can be push (always succeeds)
 *   pop n           pop             the top can be popped and returns n
 *   pop!            pop             the underflow exception is thrown
 *   clear           clear           clears the stack
 *
 *  Others
 *
 *   cout            cout << stack   print the stack (for testing only)
 *   summary                         prints the amount of memory allocated
 *                                   minus the memory deallocated
 *   details                         prints a detailed description of which
 *                                   memory was allocated with details
 *   !!                              use the previous command, e.g.  5 push_front 3
 *                                                                   6 !! 7         // same as push_front 7
 *   !n                              use the command used in line n  7 front 7
 *                                                                   8 !7 9         // same as push_front 9
 *
 ****************************************************/


void Dynamic_range_stack_tester::process() {
	if ( command == "size" ) {
		// check if the size equals the next integer read

		int expected_size;

		std::cin >> expected_size;

		int actual_size = object->size();

		if ( actual_size == expected_size ) {
			std::cout << "Okay" << std::endl;
		} else {
			std::cout << "Failure in size(): expecting the value '" << expected_size << "' but got '" << actual_size << "'" << std::endl;
		}
	} else if ( command == "capacity" ) {
		// check if the capacity equals the next integer read

		int expected_capacity;

		std::cin >> expected_capacity;

		int actual_capacity = object->capacity();

		if ( actual_capacity == expected_capacity ) {
			std::cout << "Okay" << std::endl;
		} else {
			std::cout << "Failure in capacity(): expecting the value '" << expected_capacity << "' but got '" << actual_capacity << "'" << std::endl;
		}
	} else if ( command == "empty" ) {
		// check if the empty status equals the next Boolean read

		bool expected_empty;

		std::cin >> expected_empty;

		bool actual_empty = object->empty();

		if ( actual_empty == expected_empty ) {
			std::cout << "Okay" << std::endl;
		} else {
			std::cout << "Failure in empty(): expecting the value '" << expected_empty << "' but got '" << actual_empty << "'" << std::endl;
		}
	} else if ( command == "top" ) {
		// checks if the top integer in the stack equals the next integer read

		int expected_top;

		std::cin >> expected_top;

		int actual_top = object->top();

		if ( actual_top == expected_top ) {
			std::cout << "Okay" << std::endl;
		} else {
			std::cout << "Failure in top(): expecting the value '" << expected_top << "' but got '" << actual_top << "'" << std::endl;
		}
	} else if ( command == "top!" ) {
		// top of an empty stack - catch an exception

		int actual_top;

		try {
			actual_top = object->top();
			std::cout << "Failure in top(): expecting to catch an exception but got '" << actual_top << "'" << std::endl;
		} catch( underflow ) {
			std::cout << "Okay" << std::endl;
		} catch (...) {
			std::cout << "Failure in top(): expecting an underflow exception but caught a different exception" << std::endl;
		}
	} else if ( command == "max" ) {
		// checks if the maximum integer in the stack equals the next integer read

		int expected_maximum;

		std::cin >> expected_maximum;

		int actual_maximum = object->maximum();

		if ( actual_maximum == expected_maximum ) {
			std::cout << "Okay" << std::endl;
		} else {
			std::cout << "Failure in maximum(): expecting the value '" << expected_maximum << "' but got '" << actual_maximum << "'" << std::endl;
		}
	} else if ( command == "max!" ) {
		// maximum entry in an empty stack - catch an exception

		int actual_top;

		try {
			actual_top = object->top();
			std::cout << "Failure in top(): expecting to catch an exception but got '" << actual_top << "'" << std::endl;
		} catch( underflow ) {
			std::cout << "Okay" << std::endl;
		} catch (...) {
			std::cout << "Failure in top(): expecting an underflow exception but caught a different exception" << std::endl;
		}
	} else if ( command == "min" ) {
		// checks if the minimum integer in the stack equals the next integer read

		int expected_minimum;

		std::cin >> expected_minimum;

		int actual_minimum = object->minimum();

		if ( actual_minimum == expected_minimum ) {
			std::cout << "Okay" << std::endl;
		} else {
			std::cout << "Failure in minimum(): expecting the value '" << expected_minimum << "' but got '" << actual_minimum << "'" << std::endl;
		}
	} else if ( command == "min!" ) {
		// minimum entry in an empty stack - catch an exception

		int actual_top;

		try {
			actual_top = object->top();
			std::cout << "Failure in top(): expecting to catch an exception but got '" << actual_top << "'" << std::endl;
		} catch( underflow ) {
			std::cout << "Okay" << std::endl;
		} catch (...) {
			std::cout << "Failure in top(): expecting an underflow exception but caught a different exception" << std::endl;
		}
	} else if ( command == "top" ) {
		// checks if the top integer in the stack equals the next integer read

		int expected_top;

		std::cin >> expected_top;

		int actual_top = object->top();

		if ( actual_top == expected_top ) {
			std::cout << "Okay" << std::endl;
		} else {
			std::cout << "Failure in top(): expecting the value '" << expected_top << "' but got '" << actual_top << "'" << std::endl;
		}
	} else if ( command == "top!" ) {
		// top of an empty stack - catch an exception

		int actual_top;

		try {
			actual_top = object->top();
			std::cout << "Failure in top(): expecting to catch an exception but got '" << actual_top << "'" << std::endl;
		} catch( underflow ) {
			std::cout << "Okay" << std::endl;
		} catch (...) {
			std::cout << "Failure in top(): expecting an underflow exception but caught a different exception" << std::endl;
		}
	} else if ( command == "push" ) {
		// push the next integer read to the front of the stack

		int n;

		std::cin >> n;

		object->push( n );
		std::cout << "Okay" << std::endl;
	} else if ( command == "pop" ) {
		// pop the top integer from the stack

		int expected_popped_element;

		std::cin >> expected_popped_element;

		int actual_popped_element = object->pop();

		if ( actual_popped_element == expected_popped_element ) {
			std::cout << "Okay" << std::endl;
		} else {
			std::cout << "Failure in pop(): expecting the value '" << expected_popped_element << "' but got '" << actual_popped_element << "'" << std::endl;
		}
	} else if ( command == "pop!" ) {
		// pop from an empty stack - catch an exception

		int actual_popped_element;

		try {
			actual_popped_element = object->pop();
			std::cout << "Failure in pop(): expecting to catch an exception but got '" << actual_popped_element << "'" << std::endl;
		} catch( underflow ) {
			std::cout << "Okay" << std::endl;
		} catch (...) {
			std::cout << "Failure in pop(): expecting an underflow exception but caught a different exception" << std::endl;
		}
	} else if ( command == "clear" ) {
		object->clear();

		std::cout << "Okay" << std::endl;
	} else if ( command == "cout" ) {
		std::cout << *object << std::endl;
	} else {
		std::cout << command << ": Command not found." << std::endl;
	}
}
#endif
